#include <stdio.h>

void shellSort(void);

int main(void)
{
	int arr[6] = {21, 89, 56, 9, 23, -7};
	int i, j, k, tmp;

	for(i = 1;i < 6;++i){
		if(arr[i] < arr[i-1]){//注意[0,i-1]都是有序的。如果待插入元素比arr[i-1]还大则无需再与[i-1]前面的元素进行比较了，反之则进入if语句
			tmp = arr[i];
			for(j = i-1;j >= 0 && arr[j] > tmp;--j){
				arr[j+1] = arr[j];//把比temp大或相等的元素全部往后移动一个位置
			}
			arr[j+1] = tmp;//把待排序的元素temp插入腾出位置的(j+1)
		}
	}

	for(k = 0;k < 6;++k)
		printf("%d,", arr[k]);
	printf("\n");

	shellSort();

	return 0;
}

/**
 *希尔排序Shell sort
 *希尔排序Shell Sort是基于插入排序的一种改进,同样分成两部分,
第一部分,希尔排序介绍
第二部分,如何选取关键字,选取关键字是希尔排序的关键
第一块希尔排序介绍
准备待排数组[6 2 4 1 5 9]
首先需要选取关键字,例如关键是3和1(第一步分成三组,第二步分成一组),那么待排数组分成了以下三个虚拟组:
[6 1]一组
[2 5]二组
[4 9]三组
看仔细啊,不是临近的两个数字分组,而是3(分成了三组)的倍数的数字分成了一组,
就是每隔3个数取一个,每隔三个再取一个,这样取出来的数字放到一组,
把它们当成一组,但不实际分组,只是当成一组来看,所以上边的"组"实际上并不存在,只是为了说明分组关系
对以上三组分别进行插入排序变成下边这样
[1 6] [2 5] [4 9]
具体过程:
[6 1]6和1交换变成[1 6]
[2 5]2与5不动还是[2 5]
[4 9]4与9不动还是[4 9]
第一趟排序状态演示:
待排数组:[6 2 4 1 5 9]
排后数组:[1 2 4 6 5 9]
第二趟关键字取的是1,即每隔一个取一个组成新数组,实际上就是只有一组啦,隔一取一就全部取出来了嘛
此时待排数组为:[1 2 4 6 5 9]
直接对它进行插入排序
 * */
void shellSort(void)
{
	int arr[9] = {12, 3, 21, -9, 89, 67, 7, 23, 56};

	int i, j, k, tmp, group;
	group = 9 / 2;
	while(group >= 1){
		for(i = group;i < 9;++i){
			for(j = i-group;j >= 0;j = j-group){
				if(arr[j] > arr[j+group]){
					tmp = arr[j];
					arr[j] = arr[j+group];
					arr[j+group] = tmp;
				}
			}
		}
		group = group / 2;
	}
	
	for(k = 0;k < 9;++k)
		printf("%d,", arr[k]);
	printf("\n");

	return;
}
