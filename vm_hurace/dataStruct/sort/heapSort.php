<?php
/**
 * Created by PhpStorm.
 * User: hua
 * Date: 2016-12-16
 * Time: 14:33
 */

/*
 *堆排序的实现
　　实现堆排序需要解决两个问题：
　　　　1.如何由一个无序序列建成一个堆？
　　　　2.如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？
　　先考虑第二个问题，一般在输出堆顶元素之后，视为将这个元素排除，然后用表中最后一个元素填补它的位置，自上向下进行调整：首先将堆顶元素和它的左右子树的根结点进行比较，把最小的元素交换到堆顶；然后顺着被破坏的路径一路调整下去，直至叶子结点，就得到新的堆。
　　我们称这个自堆顶至叶子的调整过程为“筛选”。
　　从无序序列建立堆的过程就是一个反复“筛选”的过程。
构造初始堆
　　初始化堆的时候是对所有的非叶子结点进行筛选。
　　最后一个非终端元素的下标是[n/2]向下取整，所以筛选只需要从第[n/2]向下取整个元素开始，从后往前进行调整。
　　比如，给定一个数组，首先根据该数组元素构造一个完全二叉树。
　　然后从最后一个非叶子结点开始，每次都是从父结点、左孩子、右孩子中进行比较交换，交换可能会引起孩子结点不满足堆的性质，所以每次交换之后需要重新对被交换的孩子结点进行调整。
进行堆排序
　　有了初始堆之后就可以进行排序了。
　　堆排序是一种选择排序。建立的初始堆为初始的无序区。
　　排序开始，首先输出堆顶元素（因为它是最值），将堆顶元素和最后一个元素交换，这样，第n个位置（即最后一个位置）作为有序区，前n-1个位置仍是无序区，对无序区进行调整，得到堆之后，再交换堆顶和最后一个元素，这样有序区长度变为2。。。
　　不断进行此操作，将剩下的元素重新调整为堆，然后输出堆顶元素到有序区。每次交换都导致无序区-1，有序区+1。不断重复此过程直到有序区长度增长为n-1，排序完成。
    当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆
 * */

//堆筛选函数
//已知H[start~end]中除了start之外均满足堆的定义
//本函数进行调整，使H[start~end]成为一个大顶堆
function heapAdjust(&$arr, $start, $end)
{
    $tmp = $arr[$start];

    for($i = 2 * $start + 1;$i <= $end;$i *= 2){

        //因为假设根结点的序号为0而不是1，所以i结点左孩子和右孩子分别为2i+1和2i+2
        if($i < $end && $arr[$i] < $arr[$i+1]){//左右孩子的比较
            ++$i;//i为较大的记录的下标
        }

        if($tmp > $arr[$i]){//左右孩子中获胜者与父亲的比较
            break;
        }

        //将孩子结点上位，则以孩子结点的位置进行下一轮的筛选
        $arr[$start] = $arr[$i];
        $start = $i;
    }

    $arr[$start] = $tmp;//插入最开始不和谐的元素

    return;
}

function heapSort(&$arr, $n)
{
    //先建立大顶堆
    for($i = intval($n/2);$i >= 0;--$i){
        heapAdjust($arr, $i, $n);
    }

    //进行排序
    for($i = $n - 1;$i > 0;--$i){

        //最后一个元素和第一元素进行交换
        $tmp = $arr[$i];
        $arr[$i] = $arr[0];
        $arr[0] = $tmp;

        //然后将剩下的无序元素继续调整为大顶堆
        heapAdjust($arr, 0, $n-1);
    }

    return;
}

$arr = array(12, 45, 67, -9, 90, 3, 11, 55);
heapSort($arr, count($arr)-1);
foreach($arr as $val)
    echo $val,',';
echo PHP_EOL;